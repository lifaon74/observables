import {
  FiniteStateKeyValueMapConstraint, IFiniteStateObservable, IFiniteStateObservableContext,
  IFiniteStateObservableKeyValueMapGeneric, TFiniteStateObservableCreateCallback, TFiniteStateObservableFinalState,
  TFiniteStateObservableState
} from './interfaces';
import { KeyValueMapToNotifications } from '../../core/notifications-observable/interfaces';
import { IObserver } from '../../../core/observer/interfaces';
import {
  IsFiniteStateObservableFinalNotificationName, ThrowFiniteStateObservableCannotEmitAfterFiniteState
} from './implementation';
import { IsObject } from '../../../helpers';

export type TBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearObserversMode =
  'none' // do nothing
  | 'recall' // the factory function is re-called if the Observable is observed
  | 'unobserve' // (default) forces all observers to unobserve this observable
  ;

export interface IBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptions {
  emitReset?: boolean; // default true => if a 'reset' notification should be emitted
  mode?: TBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearObserversMode; // default 'unobserve'
}

export interface IBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptionsStrict extends IBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptions {
  emitReset: boolean;
  mode: TBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearObserversMode;
}

/**
 * A TBuildFiniteStateObservableHookBasedOnFactoryFunctionCallback is a function taking one argument:
 * - emit: a callback function to emit some notifications.
 * And returning a 'clear' function called to interrupt the work / emit
 * INFO: a factory MUST NOT emit any values before it has returned its clear function, nor after the final state.
 */
export type TBuildFiniteStateObservableHookBasedOnFactoryFunctionCallback<T, TKVMap extends FiniteStateKeyValueMapConstraint<T, TKVMap>> =
  (
    this: IFiniteStateObservable<T, TKVMap>,
    emit: (value: KeyValueMapToNotifications<TKVMap>) => void,
    clear: (options?: IBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptions) => void,
  ) => ((this: IFiniteStateObservable<T, TKVMap>) => void);



function ThrowFactoryClearFunctionNull(): never {
  throw new Error(`Cannot emit if the factory has not returned yet or if the 'clear' function has been called`);
}

function NormalizeBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptions(options: IBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptions = {}): IBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptionsStrict {
  const _options: IBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptionsStrict = {} as any;

  if (IsObject(options)) {
    _options.emitReset = Boolean(options.emitReset);
    if (options.mode ===  void 0) {
      _options.mode = 'unobserve';
    } else if (['none', 'recall', 'unobserve'].includes(options.mode)) {
      _options.mode = options.mode;
    } else {
      throw new TypeError(`Expected 'none', 'recall' or 'unobserve'] as options.mode`);
    }
  } else {
    throw new TypeError(`Expected object or void as options`);
  }

  return _options;
}



/**
 * Creates FiniteStateObservableHook based on a 'factory' function
 * 'factory' is called once when the observable is observed and if the observable is in a 'next' state.
 * when the observable is no more observed, calls the 'clear' function of the factory. If the observable is still in a 'next' state, clears the cached values.
 * @param factory
 */
export function BuildFiniteStateObservableHookBasedOnSharedFactoryFunction<T, TKVMap extends FiniteStateKeyValueMapConstraint<T, TKVMap> = IFiniteStateObservableKeyValueMapGeneric<T>>(
  factory: TBuildFiniteStateObservableHookBasedOnFactoryFunctionCallback<T, TKVMap>,
): TFiniteStateObservableCreateCallback<T, TKVMap> {
  return function (context: IFiniteStateObservableContext<T, TKVMap>) {
    let sharedClearFactory: (() => void) | null = null;

    const clear = (instance: IFiniteStateObservable<T, TKVMap>) => {
      if (sharedClearFactory !== null) {
        const _sharedClearFactory = sharedClearFactory; // copy ref
        sharedClearFactory = null; // set to null before calling it, preventing to emit inside of _sharedClearFactory
        _sharedClearFactory.call(instance);
      }
    };

    // calls the factory
    const call = (instance: IFiniteStateObservable<T, TKVMap>) => {
      let cleared: boolean = false; // forbid calls to 'emit', if 'clear' has bee called

      const _emit = (notification: KeyValueMapToNotifications<TKVMap>) => {
        if (cleared || (sharedClearFactory === null)) {
          ThrowFactoryClearFunctionNull();
        } else {
          context.emit(notification as KeyValueMapToNotifications<TKVMap>);
        }
      };

      const _clear = (options?: IBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptions) => {
        cleared = true;

        const _options = NormalizeBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptions(options);

        if (_options.emitReset) {
          context.reset();
        }

        clear(instance);

        switch (_options.mode) {
          case 'recall':
            callIfObserved(instance);
            break;
          case 'unobserve':
            instance.clearObservers();
            break;
        }
      };

      sharedClearFactory = factory.call(instance, _emit, _clear);
    };

    // calls the factory if the observable is observed, is in a 'next' state and sharedClearFactory is null
    const callIfObserved = (instance: IFiniteStateObservable<T, TKVMap>) => {
      if (
        (instance.observers.length > 0)
        && (sharedClearFactory === null)
        && (instance.state === 'next')
      ) {
        call(instance);
      }
    };

    return {
      onObserved(): void {
        callIfObserved(this);
      },
      onUnobserved(): void {
        const instance: IFiniteStateObservable<T, TKVMap> = this;
        if (
          (sharedClearFactory !== null)  // optional check
          && !instance.observed
        ) {
          if (instance.state === 'next') {
            // clear the cache because the factory has been aborted, so the cache is inconsistent
            context.reset();
          }
          clear(instance);
        }
      },
    };
  };
}

/**
 * Creates FiniteStateObservableHook based on a 'factory' function
 * 'factory' is called for each observer
 * INFO: this mean that the 'mode' property of the FiniteStateObservable is ignored, and may be seen as a 'cache-all'
 * @param factory
 */
export function BuildFiniteStateObservableHookBasedOnPerObserverFactoryFunction<T, TKVMap extends FiniteStateKeyValueMapConstraint<T, TKVMap> = IFiniteStateObservableKeyValueMapGeneric<T>>(
  factory: TBuildFiniteStateObservableHookBasedOnFactoryFunctionCallback<T, TKVMap>,
): TFiniteStateObservableCreateCallback<T, TKVMap> {
  return function () {
    const observerClearFactory = new WeakMap<IObserver<KeyValueMapToNotifications<TKVMap>>, () => void>();

    const clear = (instance: IFiniteStateObservable<T, TKVMap>, observer: IObserver<KeyValueMapToNotifications<TKVMap>>) => {
      if (observerClearFactory.has(observer)) { // optional check (should always be true)
        const undoFactory = observerClearFactory.get(observer) as (() => void);
        observerClearFactory.delete(observer); // remove before calling it, preventing to emit inside of undoFactory
        undoFactory.call(this);
      }
    };

    return {
      onObserved(observer: IObserver<KeyValueMapToNotifications<TKVMap>>): void {
        const instance: IFiniteStateObservable<T, TKVMap> = this;
        let state: TFiniteStateObservableState = 'next';

        const _emit = (notification: KeyValueMapToNotifications<TKVMap>) => {
          const isFiniteState: boolean = IsFiniteStateObservableFinalNotificationName(notification.name);
          if (
            (state === 'next')
            || (!isFiniteState && (notification.name !== 'next'))
          ) {
            if (observerClearFactory.has(observer)) {
              if (isFiniteState) {
                state = notification.name as TFiniteStateObservableFinalState;
              } else if (notification.name === 'reset') {
                state = 'next';
              }
              observer.emit(notification as KeyValueMapToNotifications<TKVMap>, instance);
            } else {
              ThrowFactoryClearFunctionNull();
            }
          } else {
            ThrowFiniteStateObservableCannotEmitAfterFiniteState(state, notification.name);
          }
        };

        const _clear = (options?: IBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptions) => {
          cleared = true;

          const _options = NormalizeBuildFiniteStateObservableHookBasedOnFactoryFunctionCallbackClearOptions(options);

          if (_options.emitReset) {
            context.reset();
          }

          clear(instance);

          switch (_options.mode) {
            case 'recall':
              callIfObserved(instance);
              break;
            case 'unobserve':
              instance.clearObservers();
              break;
          }
        };

        observerClearFactory.set(observer, factory.call(instance, _emit));
      },
      onUnobserved(observer: IObserver<KeyValueMapToNotifications<TKVMap>>): void {
        if (observerClearFactory.has(observer)) { // optional check (should always be true)
          const undoFactory = observerClearFactory.get(observer) as (() => void);
          observerClearFactory.delete(observer); // remove before calling it, preventing to emit inside of undoFactory
          undoFactory.call(this);
        }
      },
    };
  };
}



