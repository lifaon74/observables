import { ICancellablePromise} from './interfaces';
import { setImmediate, clearImmediate } from '../../classes/set-immediate';
import { CancellablePromise } from './implementation';
import { TPromiseOrValue } from '../interfaces';
import { Reason } from '../../misc/reason/implementation';
import { ICancellablePromiseOptions, TCancellablePromiseCreateCallback } from './types';
import { IAdvancedAbortSignal } from '../../misc/advanced-abort-controller/advanced-abort-signal/interfaces';
import { TAbortStrategy } from '../../misc/advanced-abort-controller/advanced-abort-signal/types';

/**
 * Returns a CancellablePromise resolved after 'timeout' milliseconds
 */
export function $delay(timeout: number): Promise<void>;
export function $delay(timeout: number, signal: IAdvancedAbortSignal): ICancellablePromise<void, 'never'>;
export function $delay<TStrategy extends TAbortStrategy>(timeout: number, signal: IAdvancedAbortSignal, options: ICancellablePromiseOptions<void, TStrategy> | undefined): ICancellablePromise<void, TStrategy>;
export function $delay<TStrategy extends TAbortStrategy>(timeout: number, signal?: IAdvancedAbortSignal, options?: ICancellablePromiseOptions<void, TStrategy>): Promise<void> | ICancellablePromise<void, TStrategy> {
  if (signal === void 0) {
    return new Promise<void>((resolve: (value?: TPromiseOrValue<void>) => void) => {
      setTimeout(resolve, timeout);
    });
  } else {
    return new CancellablePromise<void, TStrategy>((resolve: (value?: TPromiseOrValue<void>) => void, reject: (reason?: any) => void, signal: IAdvancedAbortSignal) => {
      const abortSignalObserver = signal.addListener('abort', () => {
        clearTimeout(timer);
        abortSignalObserver.deactivate();
        reject(signal.reason);
      });

      const timer = setTimeout(() => {
        abortSignalObserver.deactivate();
        resolve();
      }, timeout);

      abortSignalObserver.activate();
    }, signal, options);
  }
}

// AbortReason
// const a1 = $delay(10);
// const a2 = $delay(10, 1 as unknown as IAdvancedAbortSignal);
// const a3 = $delay<'reject'>(10, 1 as unknown as IAdvancedAbortSignal, 2 as any);

/**
 * Returns a CancellablePromise resolved immediately after the environment has completed other operations such as events or display updates.
 */
export function $yield(signal?: IAdvancedAbortSignal): ICancellablePromise<void, 'never'>;
export function $yield<TStrategy extends TAbortStrategy>(signal: IAdvancedAbortSignal, strategy: TStrategy): ICancellablePromise<void, TStrategy>;
export function $yield<TStrategy extends TAbortStrategy>(signal?: IAdvancedAbortSignal, strategy?: TStrategy): ICancellablePromise<void, TStrategy> {
  return new CancellablePromise<void, TStrategy>((resolve: (value?: TPromiseOrValue<void>) => void, reject: (reason?: any) => void, signal: IAdvancedAbortSignal) => {
    const abortSignalObserver = signal.addListener('abort', () => {
      clearImmediate(timer);
      abortSignalObserver.deactivate();
      reject(signal.reason);
    });

    const timer = setImmediate(() => {
      abortSignalObserver.deactivate();
      resolve();
    });

    abortSignalObserver.activate();
  }, signal, strategy);
}

/**
 * Cancels a Promise after 'timeout' milliseconds
 *  -> 'signal' and 'strategy' should be omitted if 'promiseOrCallback' is a CancellablePromise
 */
export function $timeout<T>(promiseOrCallback: Promise<T> | TCancellablePromiseCreateCallback<T, 'never'>, timeout: number, signal?: IAdvancedAbortSignal): ICancellablePromise<T, 'never'>;
export function $timeout<T, TStrategy extends TAbortStrategy>(promiseOrCallback: Promise<T> | TCancellablePromiseCreateCallback<T, TStrategy>, timeout: number, signal: IAdvancedAbortSignal, strategy: TStrategy): ICancellablePromise<T, TStrategy>;
export function $timeout<T, TStrategy extends TAbortStrategy>(promiseOrCallback: Promise<T> | TCancellablePromiseCreateCallback<T, TStrategy>, timeout: number, signal?: IAdvancedAbortSignal, strategy?: TStrategy): ICancellablePromise<T, TStrategy> {
  const promise: ICancellablePromise<T, TStrategy> = CancellablePromise.of<T, TStrategy>(promiseOrCallback, signal, strategy as TStrategy);

  const delaySignal: IAdvancedAbortSignal = new CancelSignal();
  delaySignal.linkWithSignal(promise.signal);

  $delay(timeout, delaySignal)
    .then(() => {
      promise.signal.cancel(new Reason<string>(`Timeout reached`, 'TIMEOUT'));
    });

  return promise
    .finally(() => {
      delaySignal.cancel();
    });
}
